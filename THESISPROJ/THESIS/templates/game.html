<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Tailwind CSS and Font Awesome Integration -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Link to Custom Game Stylesheet -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/game.css') }}">
    <!-- Font Awesome Icons for heart and other icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Chewy&family=Fredoka:wght@300..700&family=Varela+Round&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="game-wrapper">
      <!-- Game Background -->
      <div class="game-bg" style="background-image: url('static/images/gameimg/gamebg/Multiplication Mirage.png');">
        <!-- Main Game Container (Player and Monster Section) -->
          <div class="flex justify-between items-center p-4 w-full">
            <!-- Player Section -->
            <div class="player-container">
                <p class="player-name">PLAYER NAME</p>
                <div id="player-health" class="hp-bar-container playerhp">
                </div>
            </div>

            <div class="lightning-container">
              <img src="{{ url_for('static', filename='images/anim/thunder/11.png') }}" class="sprite-lightning" />
              <img src="{{ url_for('static', filename='images/anim/thunder/22.png') }}" class="sprite-lightning" />
              <img src="{{ url_for('static', filename='images/anim/thunder/33.png') }}" class="sprite-lightning" />
              <img src="{{ url_for('static', filename='images/anim/thunder/44.png') }}" class="sprite-lightning" />
              <img src="{{ url_for('static', filename='images/anim/thunder/55.png') }}" class="sprite-lightning" />
            </div>



            <!-- Monster Section -->
            <div class="monster-container">
                <p class="monster-name">MONSTER NAME</p>
                <div id="monster-health" class="hp-bar-container monsterhp">
                </div>
          </div>
        </div>




        
        <p id="feedback"></p> <!-- Feedback area to show if answer is correct or incorrect -->

<!-- Question Section -->
<div class="question-container">
  {% if question %}
    <p id="question-text" class="question-text" data-question-id="{{ question.id }}">{{ question.question_text }}</p>
    <input type="hidden" id="question-id" value="{{ question.id }}">
    <input type="hidden" id="correct-answer" value="{{ question.correct_answer }}">
  {% else %}
    <p class="text-2xl text-red-400">No questions available for this level.</p>
  {% endif %}

  
  <!-- Freeze Turns Left -->
  <div id="freeze-turn" class="freeze-turn"></div>
</div>


<div class="menu-btn-wrapper">
  <button id="menuButton" class="menu-btn" onclick="toggleMenu()">☰ Menu</button>
</div>

<!-- Overlay that dims the background and holds the menu -->
<div id="menuOverlay" class="menu-overlay hidden">
  <div id="gameMenu" class="game-menu">
    <button class="menu-item" data-lang="resume" onclick="resumeGame()">Resume</button>
    <button class="menu-item" data-lang="restart" onclick="restartGame()">Restart</button>
    <button class="menu-item" data-lang="settings" onclick="openSettings()">Settings</button>
    <button class="menu-item" data-lang="quit" onclick="goToMainMenu()">Quit</button>
  </div>

  <!-- Settings Menu (Inside the game menu container) -->
  <div id="settingsMenu" class="game-menu hidden">
    <div class="settings-container">

      <!-- Volume Settings -->
      <div class="setting-option">
        <label for="volume" data-lang="volumeLabel">Volume</label>
        <input type="range" id="volume" min="0" max="100" value="50">
      </div>

      <!-- Mute Option aligned like Volume -->
      <div class="setting-option mute-align">
        <div class="mute-wrapper">
          <input type="checkbox" id="muteCheckbox" onchange="toggleMuteCheckbox()">
          <span class="mute-label" data-lang="muteLabel">Mute</span>
        </div>
      </div>

      <!-- Language Settings -->
      <div class="language-container">
        <label for="language" data-lang="languageLabel">Language</label>
        <div class="language-box">
          <button id="prevLanguage" onclick="changeLanguage('prev')"> &lt; </button>
          <span id="languageText">English</span>
          <button id="nextLanguage" onclick="changeLanguage('next')"> &gt; </button>
        </div>
      </div>

      <div class="settings-item-container">
        <button class="settings-item" onclick="applySettings()" data-lang="apply">Apply</button>
        <button class="settings-item" onclick="closeSettings()" data-lang="back">Back</button> <!-- Back button -->
      </div>
    </div>
  </div>
</div>



                


<!-- Combined Ground and Characters Section -->
<div class="game-container">
  <!-- Ground Section -->
  <div class="ground-container">
    <!-- Character (Wizard) -->
    <img src="{{ url_for('static', filename='images/gameimg/char/char.png') }}" alt="Wizard" class="character player">
    
<!-- Monster Character -->
<img
  id="monster-sprite"
  src="{{ url_for('static', filename='images/gameimg/mnstr/Multiplication-Mirage/Multiplication-Mob-1.png') }}"
  alt="Monster"
  class="monster monster-current"
/>


    
    <!-- Fireball (added here inside the container) -->
        <div class="fireball"></div>
    
    <!-- Ground (Platform) -->
    <div class="ground"></div>
    <img src="{{ url_for('static', filename='images/gameimg/Platforms/Multiplication Mirage.png') }}" alt="ground" class="additionground">

  </div>
</div>


<!-- Footer section for controls -->
<div class="game-control-box">
  <!-- Main game bar split into 3 sections -->
  <div class="gamecontent">

<!-- Potion Section -->
<div class="potion-section">
  <img src="{{ url_for('static', filename='images/gameimg/freeze.png') }}" class="freeze-potion" alt="Freeze Potion" onclick="useFreezePotion()">
  <img src="{{ url_for('static', filename='images/gameimg/freeze box.png') }}" class="freeze-box">
  <img src="{{ url_for('static', filename='images/gameimg/health.png') }}" class="health-potion" alt="Health Potion" onclick="useHealthPotion()">
  <img src="{{ url_for('static', filename='images/gameimg/health box.png') }}" class="health-box">
  <img src="{{ url_for('static', filename='images/gameimg/thunder.png') }}" class="thunder-potion" alt="Thunder Potion" onclick="useThunderPotion()">
  <img src="{{ url_for('static', filename='images/gameimg/thunder box.png') }}" class="thunder-box">

</div>


<!-- Game Controls -->
<div class="game-control-container">
  <!-- Number Buttons Grid -->
  <div class="button-grid">
    <div class="button" onclick="addToInput(7)"></div>
    <div class="button" onclick="addToInput(8)"></div>
    <div class="button" onclick="addToInput(9)"></div>
    <div class="button" onclick="addToInput(4)"></div>
    <div class="button" onclick="addToInput(5)"></div>
    <div class="button" onclick="addToInput(6)"></div>
    <div class="button" onclick="addToInput(1)"></div>
    <div class="button" onclick="addToInput(2)"></div>
    <div class="button" onclick="addToInput(3)"></div>
    <div class="button backspace" onclick="backspace()"></div>
    <div class="button" onclick="addToInput(0)"></div>
    <div class="button" onclick="addToInput('.')"></div>
  </div>

  <!-- Input and Attack -->
  <div class="right-section">
    <div class="placeholder-input">
      <input type="text" class="input-field" id="number-input" />
    </div>
    <div class="attack-button" onclick="handleAttack()"></div>
  </div>
  

</div>
    <!-- Chatbot Section -->
        <div class="chatbot-container">
          <div class="speech-bubble">
            <p><strong>Need help solving?</strong></p>
            <p>Start by identifying the key numbers in the problem. If it's an addition problem, look for the + sign and the numbers on either side. Try breaking the problem into smaller steps to make it easier to solve. Don't forget to check your work!</p>
            <p>Feel free to ask for a hint or solution step if you're stuck!</p>
          </div>
          <a href="{{ url_for('chatbot') }}">
            <img src="{{ url_for('static', filename='images/gameimg/counticus.png') }}" alt="Wizard Counticus" class="chatbot-img">
          </a>
        </div>


      </div>


    


  </div>
</div>









<script>
// ===== SETTINGS MENU HANDLING =====
function openSettings() {
  document.getElementById("settingsMenu").classList.remove("hidden");
  document.getElementById("gameMenu").classList.add("hidden");
}

function closeSettings() {
  currentLanguageIndex = savedLanguageIndex; // Revert to last applied language
  updateLanguageText(); // Update the display to show correct language
  document.getElementById("settingsMenu").classList.add("hidden");
  document.getElementById("gameMenu").classList.remove("hidden");
}


// ===== VOLUME CONTROL =====
const volumeSlider = document.getElementById("volume");

function updateVolumeFill() {
  const value = volumeSlider.value;
  const percentage = (value / volumeSlider.max) * 100;
  volumeSlider.style.background = `linear-gradient(to right, #4a90e2 ${percentage}%, #d3d3d3 ${percentage}%)`;
}

volumeSlider.addEventListener('input', updateVolumeFill);
updateVolumeFill(); // Initialize on load

// ===== MUTE FUNCTIONALITY =====
let isMuted = false;
let previousVolume = 50;

function toggleMuteCheckbox() {
  const muteCheckbox = document.getElementById("muteCheckbox");

  if (muteCheckbox.checked) {
    previousVolume = volumeSlider.value;
    volumeSlider.value = 0;
    isMuted = true;
  } else {
    volumeSlider.value = previousVolume;
    isMuted = false;
  }

  updateVolumeFill();
}

// Apply settings without closing the menu
function applySettings() {
  const volume = volumeSlider.value;
  const selectedLanguage = languages[currentLanguageIndex];

  console.log("Volume:", volume);
  console.log("Language:", selectedLanguage);

  savedLanguageIndex = currentLanguageIndex; // Save the selected language
  updateAllGameTexts(); // Apply language to game texts
}


// ===== GAME CONTROL =====
function restartGame() {
  location.reload();
}

function goToMainMenu() {
  window.location.href = "{{ url_for('dashboard') }}"; // Adjust if needed
}

// ===== MENU OVERLAY HANDLING =====
function toggleMenu() {
  const overlay = document.getElementById("menuOverlay");
  const menuButton = document.getElementById("menuButton");

  overlay.classList.toggle("hidden");
  menuButton.style.display = overlay.classList.contains("hidden") ? "block" : "none";
}

// Function to close the menu and resume the game
function closeOverlayAndResume() {
  const overlay = document.getElementById("menuOverlay");
  const gameMenu = document.getElementById("gameMenu");
  const menuButton = document.getElementById("menuButton");

  overlay.classList.add("hidden");
  gameMenu.classList.remove("hidden");
  menuButton.style.display = "block";
}

// New function for resume functionality (same as closeOverlayAndResume)
function resumeGame() {
  closeOverlayAndResume(); // Reusing the function to close the menu and show the game menu
}

// ===== ESC KEY FUNCTIONALITY =====
document.addEventListener('keydown', function(event) {
  if (event.key === "Escape") {
    resumeGame(); // Trigger the resumeGame function when ESC is pressed
  }
});

// ===== LANGUAGE CHANGE FUNCTIONALITY =====
// Change language based on direction
function changeLanguage(direction) {
  if (direction === 'prev') {
    currentLanguageIndex = (currentLanguageIndex - 1 + languages.length) % languages.length;
  } else if (direction === 'next') {
    currentLanguageIndex = (currentLanguageIndex + 1) % languages.length;
  }

  updateLanguageText();
}

// Update the display text for the language
function updateLanguageText() {
  const languageText = document.getElementById('languageText');
  languageText.textContent = languages[currentLanguageIndex];
}

// Update all text elements in the game
function updateAllGameTexts() {
  const language = languages[currentLanguageIndex];
  
  // Update specific buttons or elements
  document.querySelectorAll('[data-lang]').forEach(element => {
    const key = element.getAttribute('data-lang');
    if (languageData[language] && languageData[language][key]) {
      element.textContent = languageData[language][key];
    }
  });
}

let languages = ['English', 'Tagalog'];
let currentLanguageIndex = 0;
let savedLanguageIndex = 0; // <-- This stores the last applied language


// Language texts (You can expand this object as needed)
const languageData = {
  English: {
    resume: 'Resume',
    restart: 'Restart',
    settings: 'Settings',
    quit: 'Quit',
    volumeLabel: 'Volume',
    muteLabel: 'Mute',
    languageLabel: 'Language',
    apply: 'Apply',
    back: 'Back',
  },
  Tagalog: {
    resume: 'Magpatuloy',
    restart: 'Magsimula Muli',
    settings: 'Mga Setting',
    quit: 'Bumalik',
    volumeLabel: 'Bolyum',
    muteLabel: 'I-mute',
    languageLabel: 'Wika',
    apply: 'I-apply',
    back: 'Bumalik',
  },
};

</script>





<!-- POTION SCRIPT KAPAG NA CLICK NAG POPOPOUT -->
<script>
  document.querySelectorAll('.freeze-potion, .health-potion, .thunder-potion').forEach(potion => {
    potion.addEventListener('click', () => {
      potion.classList.remove('potion-clicked');
      void potion.offsetWidth; // Force reflow to restart animation
      potion.classList.add('potion-clicked');

      setTimeout(() => {
        potion.classList.remove('potion-clicked');
      }, 300); // Match with pop animation duration
    });
  });
</script>


      
<script>
  function addToInput(value) {
    const inputField = document.getElementById('number-input');
    inputField.value += value;
  }

  function backspace() {
    const inputField = document.getElementById('number-input');
    if (inputField.selectionStart !== inputField.selectionEnd) {
      inputField.value = '';
    } else {
      inputField.value = inputField.value.slice(0, -1);
    }
  }



  document.addEventListener('keydown', function(event) {
    const inputField = document.getElementById('number-input');
    if (event.ctrlKey) {
      if (event.key.toLowerCase() === 'a') {
        event.preventDefault();
        inputField.select();
      }
      return;
    }

    if (event.repeat) return;

    if (event.key === 'Backspace') {
      event.preventDefault();
      backspace();
      return;
    }

    if (event.key === 'Enter') {
      event.preventDefault();
      handleAttack();
      return;
    }

    if (event.key.length === 1) {
      if ((event.key >= '0' && event.key <= '9') || event.key === '.') {
        event.preventDefault();
        addToInput(event.key);
      } else {
        event.preventDefault();
      }
    }
  });
</script>


<script>
    let animationInterval = null;

  // ======= HP BAR LOGIC =======
  function getHpImagePath(currentHp, maxHp, isPlayer = true) {
    const hpRatio   = currentHp / maxHp;
    const scaledHp  = Math.round(hpRatio * maxHp);
    const clampedHp = Math.max(0, Math.min(scaledHp, maxHp));
    const prefix    = isPlayer ? 'player-hp-' : 'monster-hp-';
    return `{{ url_for('static', filename='images/gameimg/hpbars/') }}${prefix}${clampedHp}.png`;
  }

  const maxPlayerHealth    = 5;
  let   currentPlayerHealth = maxPlayerHealth;
  const playerHealthBar    = document.getElementById('player-health');

  let   maxMonsterHealth   = 3;  // ← let so we can reassign per monster
  let   currentMonsterHealth = maxMonsterHealth;
  const monsterHealthBar   = document.getElementById('monster-health');

  function renderHpBar(bar, curr, max, isPlayer = true) {
    bar.innerHTML = '';
    const img = document.createElement('img');
    img.src       = getHpImagePath(curr, max, isPlayer);
    img.alt       = 'HP Bar';
    img.className = 'hp-bar-image';
    bar.appendChild(img);
  }
  function updateHealthBars() {
    renderHpBar(playerHealthBar, currentPlayerHealth, maxPlayerHealth, true);
    renderHpBar(monsterHealthBar, currentMonsterHealth, maxMonsterHealth, false);
  }
  updateHealthBars();


  // ======= PLAYER HEALTH =======
  function playerHeal(amount) {
    currentPlayerHealth = Math.min(currentPlayerHealth + amount, maxPlayerHealth);
    updateHealthBars();
  }
  function playerTakeDamage() {
    if (freezePotionUsed && freezeTurns > 0) {
      freezeTurns--;
      updateFreezeTurnsDisplay();
    } else if (currentPlayerHealth > 0) {
      currentPlayerHealth--;
      updateHealthBars();
      console.log('💔 Player HP →', currentPlayerHealth);
    }
    if (freezeTurns <= 0) {
      freezePotionUsed = false;
      removeFreezeEffect();
      freezeTurnsDisplay.style.display = 'none';
    }
    checkGameOver();
  }


  // ======= MONSTER HEALTH & PROGRESSION =======
  function monsterTakeDamage() {
  const monsterImg = document.getElementById('monster-sprite');
  if (currentMonsterHealth > 0) {
    currentMonsterHealth--;
    updateHealthBars();

    if (currentMonsterHealth <= 0) {
      // Cancel freeze effect if active
      if (freezePotionUsed) {
        freezePotionUsed = false;
        freezeTurns = 0;
        removeFreezeEffect();
        freezeTurnsDisplay.style.display = 'none';
      }

      if (!monsterImg) return;

      // 1) Play death animation
      monsterImg.classList.add('monster-death');
      console.log("Death animation added");

      // 2) Once death animation is done, remove the class and spawn next monster
      monsterImg.addEventListener('animationend', function onDeath() {
        console.log("Death animation ended");  // Debugging line
        monsterImg.removeEventListener('animationend', onDeath);
        monsterImg.classList.remove('monster-death');
        monsterImg.style.opacity = '';
        monsterImg.style.transform = '';

        // 🔥 Small delay to allow reflow before triggering next monster spawn
        setTimeout(() => {
          nextMonster();
        }, 0); // 50ms delay — just enough to allow DOM updates
      });
    }
  }
  checkGameOver();
}




  // ======= GAME OVER =======
  function checkGameOver() {
    if (currentPlayerHealth <= 0) {
      setTimeout(() => alert("💀 Game Over! You lost!"), 1700);
    }
  }


  // ======= ATTACK & QUESTION =======
  function handleAttack() {
    const input  = document.getElementById('number-input').value.trim();
    const answer = document.getElementById('correct-answer').value.trim();
    if (!answer) {
      alert("No question loaded."); return;
    }
    if (input === '') {
      document.getElementById('feedback').innerText = 'Please enter a number!';
      return;
    }
    if (parseFloat(input) === parseFloat(answer)) {
      fireballAttack();
      fetchNewQuestion();
    } else {
      monsterAttack();
      displayFeedback('❌ Incorrect! Try again.');
    }
    document.getElementById('number-input').value = '';
  }

  function fetchNewQuestion() {
    fetch('/get-new-question')
      .then(r => r.json())
      .then(data => {
        const qText = document.getElementById('question-text');
        const cAns  = document.getElementById('correct-answer');
        const fb    = document.getElementById('feedback');
        if (data.question_text) {
          qText.innerText       = data.question_text;
          cAns.value            = data.correct_answer;
          fb.innerText          = '';
        } else {
          fb.innerText = 'No new question.';
        }
      })
      .catch(e => {
        console.error(e);
        document.getElementById('feedback').innerText = 'Error fetching question.';
      });
  }

  function displayFeedback(msg) {
    const fb = document.getElementById('feedback');
    fb.innerText = msg;
    fb.style.display = 'block';
    setTimeout(() => fb.style.display = 'none', 2000);
  }


  // ======= INPUT PAD =======
  function addToInput(v) {
    document.getElementById('number-input').value += v;
  }
  function backspace() {
    const f = document.getElementById('number-input');
    f.value = f.value.slice(0, -1);
  }


  // ======= POTIONS =======
  let healthPotions  = Infinity;
  let thunderPotions = Infinity;
  let freezePotions  = Infinity;

  let freezePotionUsed = false;
  let freezeTurns      = 0;
  const freezeTurnsDisplay = document.getElementById('freeze-turn');
  const monsterContainer   = document.querySelector('.monster');
  freezeTurnsDisplay.style.display = 'none';

  function useHealthPotion() {
    if (currentPlayerHealth >= maxPlayerHealth) {
      alert("🧪 Full health already!"); return;
    }
    playerHeal(4);
    alert("🧪 Health Potion used!");
  }

// GLOBAL for Thunder animation

  // Frame functions for Thunder effect
  const frames = document.querySelectorAll('.sprite-lightning');
  let currentFrame = 0;
  const monsterElement = document.querySelector('.monster');

  function resetFrames() {
    frames.forEach(f => f.classList.remove('active'));
    monsterElement.classList.remove('red');
  }

  function changeFrame() {
    resetFrames();
    frames[currentFrame].classList.add('active');
    currentFrame++;
    if (currentFrame >= frames.length) {
      clearInterval(animationInterval);
      currentFrame = 0;
      resetFrames();
      monsterElement.classList.add('red');
      setTimeout(() => monsterElement.classList.remove('red'), 70);
    }
  }

  // Thunder potion logic
  function useThunderPotion() {
    if (thunderPotions <= 0) {
      alert("⚡ No Thunder Potions left!");
      return;
    }

    // Stop previous animation if any
    if (animationInterval !== null) {
      clearInterval(animationInterval);
      resetFrames();
    }

    console.log("Thunder Potion used!");
    thunderPotions--;

    // Start thunder animation loop
    animationInterval = setInterval(changeFrame, 100);

    // Delay the monster damage animation and health reduction
    setTimeout(() => {
      const monster = document.querySelector(".monster");
      monster.classList.add("damaged");

      // Remove the damage effect after animation duration
      setTimeout(() => {
        monster.classList.remove("damaged");

        // Apply actual health reduction *after* the animation
        if (currentMonsterHealth > 0) {
          monsterTakeDamage();
        }
      }, 400); // match your CSS .damaged duration (0.4s)
    }, 660); // simulate thunder landing delay
  }

  function useFreezePotion() {
    if (freezePotions <= 0) { alert("No Freeze Potions!"); return; }
    freezePotions--;
    freezePotionUsed = true;
    freezeTurns      = 3;
    updateFreezeTurnsDisplay();
    freezeTurnsDisplay.style.display = 'block';
    applyFreezeEffect();
  }

  function updateFreezeTurnsDisplay() {
    freezeTurnsDisplay.innerText = `Freeze Turns Left: ${freezeTurns}`;
  }
  function applyFreezeEffect() {
    monsterContainer.classList.add('frozen');
  }
  function removeFreezeEffect() {
    monsterContainer.classList.remove('frozen');
  }
  
  function damagePlayer() {
  const monsterContainer = document.querySelector('.monster'); // define locally
  const player = document.querySelector('.player');

  if (!monsterContainer.classList.contains('frozen')) {
    player.classList.add('player-damaged', 'shake');
    setTimeout(() => {
      player.classList.remove('player-damaged', 'shake');
    }, 600);
  } else {
    console.log("❄️ Monster is frozen — no damage to player.");
  }
}



  // ======= ANIMATIONS (unchanged) =======
  function fireballAttack() {
  if (sessionStorage.getItem('fireballTriggered')) return;

  const attackEffects = [
    "{{ url_for('static', filename='images/anim/charattack/Addition Attack.png') }}",
    "{{ url_for('static', filename='images/anim/charattack/Subtraction Attack.png') }}",
    "{{ url_for('static', filename='images/anim/charattack/Multiplication Attack.png') }}",
    "{{ url_for('static', filename='images/anim/charattack/Division Attack.png') }}",
  ];

  const selectedAttack = attackEffects[Math.floor(Math.random() * attackEffects.length)];

  const fireball = document.createElement("img");
  fireball.src = selectedAttack;
  fireball.classList.add("fireball");

  const groundContainer = document.querySelector(".ground-container");
  const player = document.querySelector(".player");
  const monster = document.querySelector(".monster");

  fireball.style.left = `${player.offsetLeft + player.offsetWidth}px`;
  fireball.style.bottom = "120px";

  // 🔋 1. Add CHARGING class first
  player.classList.add("charging");

  setTimeout(() => {
    // 🔥 2. Remove charging, start ATTACK
    player.classList.remove("charging");
    player.classList.add("attack");

    setTimeout(() => {
      player.classList.remove("attack");
    }, 1000);

    // 🟢 3. Append the fireball after charge
    groundContainer.appendChild(fireball);
    sessionStorage.setItem('fireballTriggered', true);

    // 💥 4-A. Monster damage animation (decoupled shake and damage)
    setTimeout(() => {
      monster.classList.add("damaged"); // Visual damage effect

      setTimeout(() => {
        monster.classList.remove("damaged"); // Remove damage class
      }, 600); // Damage visual duration
    }, 860); // When animation should start

    // 💥 4-B. Shake animation (separately timed)
    setTimeout(() => {
      monster.classList.add("shake"); // Shake animation

      setTimeout(() => {
        monster.classList.remove("shake"); // Remove shake effect
      }, 600); // Shake duration
    }, 1100); // Shake starts separately

    // 💥 4-C. Apply actual damage (totally separate timing)
    setTimeout(() => {
      if (currentMonsterHealth > 0) {
        monsterTakeDamage(); // Reduce monster HP
      }
    }, 1400); // Apply damage after visuals

    // 🧼 6. Remove fireball and reset
    setTimeout(() => {
      fireball.remove();
      sessionStorage.removeItem('fireballTriggered');
    }, 1000);

  }, 600); // charging duration before attack
}




// Function for monster's attack animation
function monsterAttack() {
  const monster = document.querySelector('.monster');
  const player = document.querySelector('.player');

  // Add the attack animation class to the monster
  monster.classList.add("monster-attack");

  // After the attack animation ends, apply the damage to the player
  setTimeout(() => {
    monster.classList.remove("monster-attack"); // Remove the animation class

    // ✅ Gamitin natin yung damagePlayer() function
    damagePlayer();
    
    // Optional: actual damage logic pa rin
    setTimeout(() => {
      playerTakeDamage(); // Call the function to apply damage to the player
    }, 600); // Match sa animation duration
  }, 800); // Match sa monster attack animation
}



  // ======= MULTI-MONSTER SETUP =======
  let currentMonsterIndex = 0;
  const monstersInStage = [
    { name: 'Multiplication-Mob-1', displayName: "OASIS OGRES", maxHp: 2, image: 'Multiplication-Mob-1.png' },
    { name: 'Multiplication-Mob-2', displayName: "PRODUCT PIRANHAS", maxHp: 3, image: 'Multiplication-Mob-2.png' },
    { name: 'Multiplication-Boss-1', displayName: "PRODUCT GOLEM",  maxHp: 5, image: 'Multiplication-Boss-1.png' }
  ];

// Function to spawn the next monster with animations
function nextMonster() {
  console.log("nextMonster function called");
  currentMonsterIndex++;

  // No more monsters → victory
  if (currentMonsterIndex >= monstersInStage.length) {
    return showVictoryScreen();
  }

  // Load stats for the next monster
  const m = monstersInStage[currentMonsterIndex];
  currentMonsterHealth = m.maxHp;
  maxMonsterHealth     = m.maxHp;

  // Grab elements
  const monsterImg    = document.getElementById('monster-sprite');
  const monsterNameEl = document.querySelector('.monster-name');
  if (!monsterImg) {
    console.error('#monster-sprite missing');
    return;
  }

  // 1) Swap image
  monsterImg.src = `/static/images/gameimg/mnstr/Multiplication-Mirage/${m.image}?t=${Date.now()}`;

  // 2) Reset to base class, then add specific class for this monster
  monsterImg.className = 'monster';
  const specific = `monster-${m.name.toLowerCase()}`;
  monsterImg.classList.add(specific);

  // 3) Update monster name (clean formatting)
  if (monsterNameEl) {
    monsterNameEl.textContent = m.displayName || m.name.replace(/-/g, ' ');
  }

  // 4) Spawn animation — reflow trick para always trigger
  monsterImg.classList.remove('monster-spawn'); // remove old animation
  void monsterImg.offsetWidth;                 // force reflow 🔥
  monsterImg.classList.add('monster-spawn');   // re-add animation

  // 5) Clean up after the spawn animation ends
  monsterImg.addEventListener('animationend', function clearSpawn() {
    monsterImg.classList.remove('monster-spawn');
    monsterImg.removeEventListener('animationend', clearSpawn);
  });

  console.log('Applying class:', specific);

  // 6) Update UI (Health bar, new question)
  updateHealthBars();
  fetchNewQuestion();
}







  function showVictoryScreen() {
    alert("🏆 Stage Cleared! You defeated all monsters!");
    const rewards = ['health','freeze','thunder'];
    const bonus   = rewards[Math.floor(Math.random()*rewards.length)];
    alert(`🎁 You got a bonus ${bonus} potion!`);
    // TODO: next stage or exit map
  }

  // ======= INITIAL LOAD =======
  window.addEventListener('DOMContentLoaded', () => {
  // First monster
  const m = monstersInStage[0];
  currentMonsterHealth = m.maxHp;
  maxMonsterHealth     = m.maxHp;

  const monsterImg = document.getElementById('monster-sprite');
  if (!monsterImg) {
    console.error('#monster-sprite missing on load');
    return;
  }

  // Sync the monster name display
  const monsterNameEl = document.querySelector('.monster-name');
  if (monsterNameEl) {
    // Turn “Multiplication-Mob-1” into “Multiplication Mob 1” (or whatever you prefer)
    monsterNameEl.textContent = m.displayName || m.name.replace(/-/g, ' ');
  }

  // Set the initial image for the monster
  monsterImg.src = `/static/images/gameimg/mnstr/Multiplication-Mirage/${m.image}`;

  // Reset to base 'monster' class and add the specific class
  monsterImg.className = 'monster';
  const specific = `monster-${m.name.toLowerCase()}`;
  monsterImg.classList.add(specific);

  // Spawn animation on first load
  monsterImg.classList.add('monster-spawn');
  monsterImg.addEventListener('animationend', () => {
    monsterImg.classList.remove('monster-spawn');
  });

  console.log('Initial monster class:', monsterImg.className);

  // Update health bars and load the first question
  updateHealthBars();
  fetchNewQuestion();
});



</script>



  


  







  </body>
</html>
